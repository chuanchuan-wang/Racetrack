
import java.awt.Color;
import java.awt.Component;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.io.IOException;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JTabbedPane;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author chuan
 */
public class DesignTrack extends javax.swing.JFrame {

    /**
     * Creates new form DesignTrack
     */
    public DesignTrack(int customiseTrack, String[] trackName, boolean computerPlayer, boolean hint) {
        computerPlayerDT = computerPlayer;
        hintDT = hint;

        customiseTrackNumber = customiseTrack;
        customiseTrackName = trackName;

        initComponents();
        GridPanel.add(drawG);
        gridLayout = new GridLayout();
        gridLayout.setRows(1);
        gridLayout.setColumns(2);
        //checkPanel.setBackground(Color.red);
        createNewTrackB.setEnabled(false);

        if (hintDT) {
            ruleD = new RuleDialog(2);
            ruleD.setVisible(true);
        }
    }

    private void addTrackMouseEvent(MouseEvent evt) {
        JLabel temp = (JLabel) evt.getSource();
        String name[] = temp.getName().split(" ");
        if (!grayB.isEnabled()) {
            temp.setBackground(Color.DARK_GRAY);
            drawG.arr[Integer.valueOf(name[0])][Integer.valueOf(name[1])] = 2;
            drawG.trackChanged = true;
        } else if (!whiteB.isEnabled()) {
            temp.setBackground(Color.LIGHT_GRAY);
            drawG.arr[Integer.valueOf(name[0])][Integer.valueOf(name[1])] = 3;
            drawG.trackChanged = true;
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jToolBar1 = new javax.swing.JToolBar();
        BackButtom = new javax.swing.JButton();
        ruleButton = new javax.swing.JButton();
        jTabbedPane = new javax.swing.JTabbedPane();
        barrierPanel = new javax.swing.JPanel();
        whiteB = new javax.swing.JButton();
        grayB = new javax.swing.JButton();
        BarrierL = new javax.swing.JLabel();
        PathwayL = new javax.swing.JLabel();
        BarrierPanel = new javax.swing.JPanel();
        checkpointPanel = new javax.swing.JPanel();
        GridPanel = new javax.swing.JPanel();
        startPointB = new javax.swing.JButton();
        finishLineB = new javax.swing.JButton();
        checkpointB = new javax.swing.JButton();
        checkPanel = new javax.swing.JPanel();
        createNewTrackB = new javax.swing.JButton();
        startPointLabel = new javax.swing.JLabel();
        finishLineLabel = new javax.swing.JLabel();
        checkPointLabel = new javax.swing.JLabel();
        drawB = new javax.swing.JButton();
        drawLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Design Track");
        setResizable(false);

        jToolBar1.setRollover(true);

        BackButtom.setText("Back");
        BackButtom.setFocusable(false);
        BackButtom.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        BackButtom.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        BackButtom.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                BackButtomMouseClicked(evt);
            }
        });
        jToolBar1.add(BackButtom);

        ruleButton.setText("Rule");
        ruleButton.setFocusable(false);
        ruleButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        ruleButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        ruleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ruleButtonActionPerformed(evt);
            }
        });
        jToolBar1.add(ruleButton);

        jTabbedPane.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jTabbedPaneStateChanged(evt);
            }
        });

        whiteB.setText("WHITE");
        whiteB.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                whiteBMouseClicked(evt);
            }
        });

        grayB.setText("GRAY");
        grayB.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                grayBMouseClicked(evt);
            }
        });

        BarrierL.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        BarrierL.setText("Barrier");

        PathwayL.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        PathwayL.setText("Pathway");

        BarrierPanel.setPreferredSize(new java.awt.Dimension(500, 500));
        BarrierPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                BarrierPanelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                BarrierPanelMouseReleased(evt);
            }
        });
        BarrierPanel.setLayout(new java.awt.BorderLayout());

        javax.swing.GroupLayout barrierPanelLayout = new javax.swing.GroupLayout(barrierPanel);
        barrierPanel.setLayout(barrierPanelLayout);
        barrierPanelLayout.setHorizontalGroup(
            barrierPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(barrierPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarrierPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(40, 40, 40)
                .addGroup(barrierPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(BarrierL, javax.swing.GroupLayout.DEFAULT_SIZE, 76, Short.MAX_VALUE)
                    .addComponent(grayB, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(barrierPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(PathwayL, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(whiteB, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(50, Short.MAX_VALUE))
        );
        barrierPanelLayout.setVerticalGroup(
            barrierPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(barrierPanelLayout.createSequentialGroup()
                .addGroup(barrierPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(barrierPanelLayout.createSequentialGroup()
                        .addGap(201, 201, 201)
                        .addGroup(barrierPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(BarrierL)
                            .addComponent(PathwayL))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(barrierPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(grayB)
                            .addComponent(whiteB)))
                    .addGroup(barrierPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(BarrierPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jTabbedPane.addTab("Barrier & Pathway", barrierPanel);

        GridPanel.setPreferredSize(new java.awt.Dimension(500, 500));
        GridPanel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                GridPanelMouseMoved(evt);
            }
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                GridPanelMouseDragged(evt);
            }
        });
        GridPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                GridPanelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                GridPanelMouseReleased(evt);
            }
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                GridPanelMouseClicked(evt);
            }
        });
        GridPanel.setLayout(new java.awt.BorderLayout());

        startPointB.setText("Start Point");
        startPointB.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                startPointBMouseClicked(evt);
            }
        });

        finishLineB.setText("Finish Line");
        finishLineB.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                finishLineBMouseClicked(evt);
            }
        });

        checkpointB.setText("Checkpoint Line");
        checkpointB.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                checkpointBMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout checkPanelLayout = new javax.swing.GroupLayout(checkPanel);
        checkPanel.setLayout(checkPanelLayout);
        checkPanelLayout.setHorizontalGroup(
            checkPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        checkPanelLayout.setVerticalGroup(
            checkPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 214, Short.MAX_VALUE)
        );

        createNewTrackB.setText("Finish");
        createNewTrackB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                createNewTrackBActionPerformed(evt);
            }
        });

        startPointLabel.setText("✘ ");

        finishLineLabel.setText("✘ ");

        checkPointLabel.setText("✘ ");

        drawB.setText("Draw");
        drawB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                drawBActionPerformed(evt);
            }
        });

        drawLabel.setText("✘ ");

        javax.swing.GroupLayout checkpointPanelLayout = new javax.swing.GroupLayout(checkpointPanel);
        checkpointPanel.setLayout(checkpointPanelLayout);
        checkpointPanelLayout.setHorizontalGroup(
            checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(checkpointPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(GridPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(checkpointPanelLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(createNewTrackB))
                    .addGroup(checkpointPanelLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(checkPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(checkpointPanelLayout.createSequentialGroup()
                                .addComponent(checkpointB, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(checkPointLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, checkpointPanelLayout.createSequentialGroup()
                                .addComponent(startPointB, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(startPointLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, checkpointPanelLayout.createSequentialGroup()
                                .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(finishLineB, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(drawB, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(finishLineLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(drawLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                .addContainerGap())
        );
        checkpointPanelLayout.setVerticalGroup(
            checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, checkpointPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(checkpointPanelLayout.createSequentialGroup()
                        .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(checkpointPanelLayout.createSequentialGroup()
                                .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(drawB)
                                    .addComponent(drawLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(35, 35, 35))
                            .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(startPointB)
                                .addComponent(startPointLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(finishLineB)
                            .addComponent(finishLineLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(checkpointPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(checkpointB)
                            .addComponent(checkPointLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(checkPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(createNewTrackB))
                    .addComponent(GridPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jTabbedPane.addTab("Point & Line", checkpointPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, 775, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, 554, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void grayBMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_grayBMouseClicked
        // TODO add your handling code here:
        grayB.setEnabled(false);
        whiteB.setEnabled(true);
    }//GEN-LAST:event_grayBMouseClicked

    private void BarrierPanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_BarrierPanelMousePressed
        // TODO add your handling code here:
        System.out.println("Pressed " + panelNumber);
        for (int i = 1; i < total_width - 1; i++) {
            for (int j = 1; j < total_height - 1; j++) {
                labelArr[i][j].addMouseListener(new java.awt.event.MouseAdapter() {
                    public void mouseEntered(java.awt.event.MouseEvent evt) {
                        addTrackMouseEvent(evt);
                    }
                });
            }
        }
    }//GEN-LAST:event_BarrierPanelMousePressed

    private void BarrierPanelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_BarrierPanelMouseReleased
        // TODO add your handling code here:
        System.out.println("Released " + panelNumber);
        removeLabelMouseListener();
    }//GEN-LAST:event_BarrierPanelMouseReleased

    private void whiteBMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_whiteBMouseClicked
        // TODO add your handling code here:
        grayB.setEnabled(true);
        whiteB.setEnabled(false);
    }//GEN-LAST:event_whiteBMouseClicked

    private void jTabbedPaneStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jTabbedPaneStateChanged
        // TODO add your handling code here:
        if (init) {
            init = false;
            drawG = new DrawGrid(customiseTrackName);
            //drawG.generateRectangleList();
            BarrierPanel.setLayout(new GridLayout(total_width, total_height));
            for (int i = 0; i < total_width; i++) {
                for (int j = 0; j < total_height; j++) {
                    labelArr[i][j] = new JLabel();
                    labelArr[i][j].setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));
                    labelArr[i][j].setBackground(Color.LIGHT_GRAY);
                    //System.out.println("(i,j) = (" + i + "," + j + ")");
                    drawG.arr[i][j] = 3;
                    if (i == 0 || j == 0 || i == total_width - 1 || j == total_height - 1) {
                        labelArr[i][j].setBackground(Color.DARK_GRAY);
                        drawG.arr[i][j] = 2;
                    }
                    labelArr[i][j].setOpaque(true);
                    labelArr[i][j].setName(i + " " + j);
                    BarrierPanel.add(labelArr[i][j]);
                }
            }
            System.out.println("init");
        }
        jTabbedPane = (JTabbedPane) evt.getSource();
        panelNumber = jTabbedPane.getSelectedIndex();
        System.out.println("Select pane :" + jTabbedPane.getSelectedIndex());
        if (panelNumber == 0) {
            startPointB.setEnabled(true);
            finishLineB.setEnabled(true);
            checkpointB.setEnabled(true);
            if (drawG.tempPointExist) {
                drawG.tempPointExist = false;
                if (initStartPoint) {
                    drawG.startPointExist = true;
                }
            }
        } else if (panelNumber == 1) {
            anyChanged = drawG.trackChanged;
            GridPanel.repaint();
        }

        if (anyChanged) {
            System.out.println("Check after changing tab");
            anyChanged = false;
            drawG.generateRectangleList();
            drawG.resetDrawPath();
            checkLegal(0);
            checkStatus();
            finishButtonEnable();
        }
    }//GEN-LAST:event_jTabbedPaneStateChanged

    private void GridPanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_GridPanelMousePressed
        // TODO add your handling code here:
        drawG.selectCheckpointLineBoolean = false;
        if (!finishLineB.isEnabled() || !checkpointB.isEnabled()) {
            startP = null;
            Point p = evt.getPoint();
            for (int i = 0; i < drawG.rectList.size(); i++) {
                if (drawG.rectList.get(i).contains(p)) {
                    startP = new Point2D.Double(drawG.rectList.get(i).getX(), drawG.rectList.get(i).getY());
                    System.out.println("(LINE) startP " + drawG.rectList.get(i).getX() + " " + drawG.rectList.get(i).getY());
                }
            }
            GridPanel.repaint();
        }
    }//GEN-LAST:event_GridPanelMousePressed

    private void GridPanelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_GridPanelMouseReleased
        // TODO add your handling code here:
        //gridPanelMouseMovedWork = false;
        if (finishP != null) {
            if (!finishLineB.isEnabled() || !checkpointB.isEnabled()) {
                if (drawG.gridPanelDragged) {
                    System.out.println(startP.getX() + " " + startP.getY());
                    System.out.println(finishP.getX() + " " + finishP.getY());
                    if (!checkpointB.isEnabled()) {
                        if (drawG.checkpointLine.size() < 7) {
                            //checkpoint is duplicate or not
                            boolean exist = false;
                            for (int i = 0; i < drawG.checkpointLine.size(); i++) {
                                if (Line2DEqual(drawG.tempLine, drawG.checkpointLine.get(i))) {
                                    JOptionPane.showMessageDialog(rootPane, "This checkpoint line exists!", "WARNING", JOptionPane.INFORMATION_MESSAGE);
                                    exist = true;
                                    break;
                                }
                            }
                            if (!exist) {
                                drawG.checkpointLine.add(drawG.tempLine);
                                showChekpointPanel();
                                checkLegal(3);
                            }
                        } else {
                            JOptionPane.showMessageDialog(rootPane, "Delete some checkpoint line before adding more.", "WARNING", JOptionPane.INFORMATION_MESSAGE);
                        }
                    } else {//!finishLineB.isEnable()
                        drawG.finishLine = drawG.tempLine;
                        drawG.finishLineExist = true;
                        checkLegal(2);
                    }
                    drawG.gridPanelDragged = false;
                    GridPanel.repaint();
                    anyChanged = true;
                }
            }
            if (anyChanged) {
                System.out.println("Check after drawing line");
                anyChanged = false;
                drawG.resetDrawPath();
                checkStatus();
                finishButtonEnable();
            }
        }
    }//GEN-LAST:event_GridPanelMouseReleased

    private void GridPanelMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_GridPanelMouseDragged
        // TODO add your handling code here:
        if (startP != null) {
            if (!finishLineB.isEnabled() || !checkpointB.isEnabled()) {
                finishP = null;
                Point p = evt.getPoint();
                for (int i = 0; i < drawG.rectList.size(); i++) {
                    if (drawG.rectList.get(i).contains(p)) {
                        finishP = new Point2D.Double(drawG.rectList.get(i).getX(), drawG.rectList.get(i).getY());
                        drawG.tempLine = new Line2D.Double(startP, finishP);
                        break;
                    }
                }
                if (finishP == null) {
                    drawG.gridPanelDragged = false;
                }else{
                    drawG.gridPanelDragged = true;
                }
                GridPanel.repaint();
            }
        }
    }//GEN-LAST:event_GridPanelMouseDragged

    private void finishLineBMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_finishLineBMouseClicked
        // TODO add your handling code here:
        startPointB.setEnabled(true);
        finishLineB.setEnabled(false);
        checkpointB.setEnabled(true);
        drawG.gridPanelDragged = false;
        drawG.selectCheckpointLineBoolean = false;

        if (drawG.tempPointExist) {
            drawG.tempPointExist = false;
            if (initStartPoint) {
                drawG.startPointExist = true;
            }
            GridPanel.repaint();
        }
        System.out.println("Finish Button");
    }//GEN-LAST:event_finishLineBMouseClicked

    private void startPointBMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_startPointBMouseClicked
        // TODO add your handling code here:
        startPointB.setEnabled(false);
        finishLineB.setEnabled(true);
        checkpointB.setEnabled(true);
        drawG.startPointExist = false;
        drawG.selectCheckpointLineBoolean = false;
        System.out.println("Start Button");
    }//GEN-LAST:event_startPointBMouseClicked

    private void checkpointBMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_checkpointBMouseClicked
        // TODO add your handling code here:
        startPointB.setEnabled(true);
        finishLineB.setEnabled(true);
        checkpointB.setEnabled(false);
        drawG.gridPanelDragged = false;
        drawG.selectCheckpointLineBoolean = false;

        if (drawG.tempPointExist) {
            drawG.tempPointExist = false;
            if (initStartPoint) {
                drawG.startPointExist = true;
            }
            GridPanel.repaint();
        }
        System.out.println("CheckPoint Button");

    }//GEN-LAST:event_checkpointBMouseClicked

    private void GridPanelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_GridPanelMouseClicked
        // TODO add your handling code here:
        if (!startPointB.isEnabled()) {// comfirm start point
            System.out.println("Temp = " + drawG.tempPoint.x + " " + drawG.tempPoint.y);
            drawG.startPoint = drawG.tempPoint;
            drawG.startPointExist = true;
            drawG.tempPointExist = false;
            initStartPoint = true;
            GridPanel.repaint();
            anyChanged = true;
            startPointB.setEnabled(true);
        }
        if (anyChanged) {
            System.out.println("Check after drawing point");
            anyChanged = false;
            checkLegal(1);
            drawG.resetDrawPath();
            checkStatus();
            finishButtonEnable();
        }
    }//GEN-LAST:event_GridPanelMouseClicked

    private void GridPanelMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_GridPanelMouseMoved
        // TODO add your handling code here:
        if (!startPointB.isEnabled()) {// choose start point
            Point p = evt.getPoint();
            for (int i = 0; i < drawG.rectList.size(); i++) {
                if (drawG.rectList.get(i).contains(p)) {
                    drawG.tempPoint = new Point(drawG.rectList.get(i).x, drawG.rectList.get(i).y);
                    drawG.tempPointExist = true;
                    break;
                }
            }
            GridPanel.repaint();
        } else if (drawG.drawProgress) {// draw - progress
            Point p = evt.getPoint();
            drawG.drawPath(p);
            if (drawG.drawCrash) {// draw - illegal path
                drawB.setEnabled(true);
            }
            GridPanel.repaint();
        } else if (drawG.drawStart) {// draw - from the start point
            Point p = evt.getPoint();
            //if (p.x == drawG.startPoint.x && p.y == drawG.startPoint.y) {
            if (p.distance(drawG.startPoint) < 3) {
                drawG.drawProgress = true;
                drawG.pointList.add(drawG.startPoint);
                System.out.println("Here!!!!!!");
            }
        } else if (drawG.drawLegal) {// draw - completed
            checkStatus();
            finishButtonEnable();
        }
    }//GEN-LAST:event_GridPanelMouseMoved

    private void createNewTrackBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_createNewTrackBActionPerformed
        // TODO add your handling code here:
        //String str = drawG.checkTrack();
        //warningLabel.setText("<html>" + str + "</html>");
        //JOptionPane.showMessageDialog(rootPane, "Finish!!!", "WARNING", JOptionPane.INFORMATION_MESSAGE);
        String name = "";
        try {
            name = drawG.creatNewTrack(customiseTrackNumber);
        } catch (IOException ex) {
            //Logger.getLogger(DesignTrack.class.getName()).log(Level.SEVERE, null, ex);
        }
        if (!drawG.createFail) {
            try {
                TrackFrame trackF = new TrackFrame(false, computerPlayerDT, hintDT);
                trackF.setVisible(true);
                if (ruleD != null) {
                    ruleD.dispose();
                }
                this.setVisible(false);
            } catch (IOException ex) {
                //Logger.getLogger(DesignTrack.class.getName()).log(Level.SEVERE, null, ex);
            }

            Thread thread = new Thread(new Runnable() {
                public void run() {
                    System.out.println("Run in thread!");
                    try {
                        drawG.creatNewTrackCP();
                    } catch (IOException ex) {
                        //Logger.getLogger(DesignTrack.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    if (!drawG.createFail) {
                        System.out.println("Thread end!!");
                        dispose();
                    }
                }
            });
            thread.setName(name);
            thread.start();
        }
    }//GEN-LAST:event_createNewTrackBActionPerformed

    private void BackButtomMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_BackButtomMouseClicked
        // TODO add your handling code here:
        // give up create a new track
        TrackFrame trackF;
        try {
            trackF = new TrackFrame(false, computerPlayerDT, hintDT);
            trackF.setVisible(true);
        } catch (IOException ex) {
            //Logger.getLogger(DesignTrack.class.getName()).log(Level.SEVERE, null, ex);
        }
        if (ruleD != null) {
            ruleD.dispose();
        }
        dispose();
    }//GEN-LAST:event_BackButtomMouseClicked

    private void drawBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_drawBActionPerformed
        // TODO add your handling code here:
        // button for drawing
        startPointB.setEnabled(true);
        finishLineB.setEnabled(true);
        checkpointB.setEnabled(true);
        drawB.setEnabled(false);
        drawG.drawStart = true;
    }//GEN-LAST:event_drawBActionPerformed

    private void ruleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ruleButtonActionPerformed
        // TODO add your handling code here:
        if (ruleD == null) {
            ruleD = new RuleDialog(2);
            ruleD.setVisible(true);
        } else {
            if (ruleD.isShowing()) {
                ruleD.setVisible(false);
            } else {
                ruleD.setVisible(true);
            }
        }
    }//GEN-LAST:event_ruleButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(DesignTrack.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(DesignTrack.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(DesignTrack.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(DesignTrack.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                //new DesignTrack(0).setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton BackButtom;
    private javax.swing.JLabel BarrierL;
    private javax.swing.JPanel BarrierPanel;
    private javax.swing.JPanel GridPanel;
    private javax.swing.JLabel PathwayL;
    private javax.swing.JPanel barrierPanel;
    private javax.swing.JPanel checkPanel;
    private javax.swing.JLabel checkPointLabel;
    private javax.swing.JButton checkpointB;
    private javax.swing.JPanel checkpointPanel;
    private javax.swing.JButton createNewTrackB;
    private javax.swing.JButton drawB;
    private javax.swing.JLabel drawLabel;
    private javax.swing.JButton finishLineB;
    private javax.swing.JLabel finishLineLabel;
    private javax.swing.JButton grayB;
    private javax.swing.JTabbedPane jTabbedPane;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JButton ruleButton;
    private javax.swing.JButton startPointB;
    private javax.swing.JLabel startPointLabel;
    private javax.swing.JButton whiteB;
    // End of variables declaration//GEN-END:variables
    private boolean computerPlayerDT;
    private boolean hintDT;
    private final static int total_width = 40;
    private final static int total_height = 40;
    private JLabel[][] labelArr = new JLabel[total_width][total_height];
    private int panelNumber = 0;
    private boolean init = true;

    private final static String STR_CHECK = "✔";
    private final static String STR_CROSS = "✘";

    //public int arr[][] = new int[total_width + 1][total_height];
    private Point2D startP;
    private Point2D finishP;

    private DrawGrid drawG;
    private GridLayout gridLayout;

    //public boolean trackChanged = true;
    //public boolean gridPanelDragged = false;
    //public boolean selectCheckpointLine = false;
    //public boolean tempPointBoolean = false;
    private boolean startLegalDT = false;
    private boolean finishLineLegalDT = false;
    private boolean checkpointLineLegalDT = false;
    private boolean drawLegalDT = false;
    private boolean initStartPoint = false;
    //public boolean drawing = false;
    //public boolean drawStart = false;

    private boolean anyChanged = false;

    private int customiseTrackNumber;
    private String customiseTrackName[] = new String[6];
    private RuleDialog ruleD = null;

    private void removeLabelMouseListener() {
        for (int i = 0; i < total_width; i++) {
            for (int j = 0; j < total_height; j++) {
                MouseListener[] mouseL = labelArr[i][j].getMouseListeners();
                for (int temp = 0; temp < mouseL.length; temp++) {
                    labelArr[i][j].removeMouseListener(mouseL[temp]);
                }
            }
        }
    }

    private void showChekpointPanel() {
        // checkpoin line label and button
        String name = drawG.tempLine.getX1() + " " + drawG.tempLine.getY1() + " " + drawG.tempLine.getX2() + " " + drawG.tempLine.getY2();
        System.out.println(name);

        //checkpointPanel.setLayout(new java.awt.GridLayout(3, 3, 10, 20));
        gridLayout.setRows(drawG.checkpointLine.size());
        checkPanel.setLayout(gridLayout);

        JLabel l = new JLabel();
        JButton b = new JButton();

        l.setName(name);
        b.setName(name);

        l.setText("(" + drawG.computePosition((int) drawG.tempLine.getX1(), true) + "," + drawG.computePosition((int) drawG.tempLine.getY1(), false) + ")(" + drawG.computePosition((int) drawG.tempLine.getX2(), true) + "," + drawG.computePosition((int) drawG.tempLine.getY2(), false) + ")");
        b.setText("Delete");

        l.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                JLabel clickedL = (JLabel) evt.getSource();
                String name[] = clickedL.getName().split(" ");
                drawG.selectCheckpointLine = new Line2D.Double(Double.valueOf(name[0]), Double.valueOf(name[1]), Double.valueOf(name[2]), Double.valueOf(name[3]));
                drawG.selectCheckpointLineBoolean = true;
                GridPanel.repaint();
            }
        });
        b.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                drawG.resetDrawPath();
                checkStatus();
                finishButtonEnable();
                JButton clickedB = (JButton) evt.getSource();
                Component[] comp = checkPanel.getComponents();
                // Find the label with the same name
                for (int index = 0; index < comp.length; index++) {
                    if (comp[index].getName().equals(clickedB.getName())) {
                        checkPanel.remove(comp[index]);
                        break;
                    }
                }
                drawG.selectCheckpointLineBoolean = false;
                //Delete the line from the list
                String name[] = clickedB.getName().split(" ");
                Line2D tempL = new Line2D.Double(Double.valueOf(name[0]), Double.valueOf(name[1]), Double.valueOf(name[2]), Double.valueOf(name[3]));
                for (int i = 0; i < drawG.checkpointLine.size(); i++) {
                    Line2D deleteL = drawG.checkpointLine.get(i);
                    //System.out.println(deleteL.getX1() + "=" + tempL.getX1() + "," + deleteL.getX2() + "=" + tempL.getX2() + "," + deleteL.getY1() + "=" + tempL.getY1() + "," + deleteL.getY2() + "=" + tempL.getY2());
                    if (Line2DEqual(deleteL, tempL)) {
                        drawG.checkpointLine.remove(deleteL);
                        System.out.println("Delete!!!");
                        break;
                    }
                }
                if (drawG.checkpointLine.isEmpty()) {
                    checkpointLineLegalDT = false;
                    checkStatus();
                }
                System.out.println("Size = " + drawG.checkpointLine.size());
                checkPanel.remove(clickedB);
                gridLayout.setRows(drawG.checkpointLine.size());
                checkPanel.setLayout(gridLayout);
                checkPanel.updateUI();
                if (initStartPoint) {
                    drawG.startPointExist = true;
                }

                GridPanel.repaint();
                if (drawG.checkpointLine.isEmpty()) {
                    createNewTrackB.setEnabled(false);
                }
            }
        });

        l.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        b.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        checkPanel.add(l);
        checkPanel.add(b);
        checkPanel.updateUI();
        //checkPanel.repaint();
    }

    private boolean Line2DEqual(Line2D l1, Line2D l2) {
        return (l1.getX1() == l2.getX1() && l1.getX2() == l2.getX2() && l1.getY1() == l2.getY1() && l1.getY2() == l2.getY2());
    }

    public void checkLegal(int i) {
        boolean all = false;
        switch (i) {
            case 0:
                all = true;
            case 1:
                if (drawG.startPointExist) {
                    startLegalDT = false;
                    startLegalDT = drawG.checkTrack(drawG.startPoint);
                    System.out.println("(C)Check start point");
                    if (!all) {
                        break;
                    }
                }
            case 2:
                if (drawG.finishLineExist) {
                    finishLineLegalDT = false;
                    finishLineLegalDT = drawG.checkTrack(drawG.finishLine);
                    System.out.println("(C)Check finish line");
                    if (!all) {
                        break;
                    }
                }
            case 3:
                if (!drawG.checkpointLine.isEmpty()) {
                    checkpointLineLegalDT = true;
                } else {
                    checkpointLineLegalDT = false;
                }
                for (int index = 0; index < drawG.checkpointLine.size(); index++) {
                    if (!drawG.checkTrack(drawG.checkpointLine.get(index))) {
                        checkpointLineLegalDT = false;
                    }
                }
                System.out.println("(C)Check checkpoint line");
                if (!all) {
                    break;
                }
        }
    }

    public void checkStatus() {
        // check whether the status for draw, start point, finish line, checkpoint line
        if (startLegalDT) {// start point
            startPointLabel.setText(STR_CHECK);
            startPointLabel.setForeground(Color.GREEN);
        } else {
            startPointLabel.setText(STR_CROSS);
            startPointLabel.setForeground(Color.RED);
        }
        if (finishLineLegalDT) {// finish line
            finishLineLabel.setText(STR_CHECK);
            finishLineLabel.setForeground(Color.GREEN);
        } else {
            finishLineLabel.setText(STR_CROSS);
            finishLineLabel.setForeground(Color.RED);
        }
        if (checkpointLineLegalDT) {// checkpoint line
            checkPointLabel.setText(STR_CHECK);
            checkPointLabel.setForeground(Color.GREEN);
        } else {
            checkPointLabel.setText(STR_CROSS);
            checkPointLabel.setForeground(Color.RED);
        }
        if (drawG.drawLegal) {// draw a possible path
            drawLabel.setText(STR_CHECK);
            drawLabel.setForeground(Color.GREEN);
            drawG.drawStart = false;
        } else if (startLegalDT && finishLineLegalDT && checkpointLineLegalDT) {// able to draw
            drawLabel.setText(STR_CROSS);
            drawLabel.setForeground(Color.RED);
            drawB.setEnabled(true);
            drawG.drawStart = false;
        } else {// not able to draw
            drawLabel.setText(STR_CROSS);
            drawLabel.setForeground(Color.RED);
            drawB.setEnabled(false);
            drawG.drawStart = false;
        }
    }

    public void finishButtonEnable() {
        //check whether the track is legal or not
        if (startLegalDT && finishLineLegalDT && checkpointLineLegalDT && drawG.drawLegal) {
            createNewTrackB.setEnabled(true);
        } else {
            createNewTrackB.setEnabled(false);
        }
    }
}
